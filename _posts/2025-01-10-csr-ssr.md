---
title: "CSR과 SSR"
name: 꼽사리구나
writer: 꼽사리구나
categories: [CS, CSR과 SSR]
tags:
  - [CS, CSR, SSR]
toc: true
toc_sticky: true
date: 2025-01-10
last_modified_at: 2025-01-10
---

------------------------------------------------------------------------------------------------------------------------------------------------

# <span style="color:green">CSR(Client Side Rendering)</span>
CSR을 브라우저에서 직접 페이지를 렌더링하는 것을 말한다.  
CSR은 브라우저가 서버에 HTML과 JS 파일을 요청한 후 로드되면 사용자의 상호작용에 따라 자바스크립트를 사용해 동적으로 렌더링한다.  
`렌더링 : 실시간으로 웹 사이트가 그려지는 과정`

##### <span style="color:brown">CSR 동작 과정</span>
![csr](https://github.com/user-attachments/assets/3b07a20b-a8f7-482a-9e9f-8af842e0cf2a)  
1. User가 WebSite 요청을 보낸다.
2. CDN이 html파일과 Js로 접근할 수 있는 링크를 클라이언트로 보낸다.
3. 클라이언트는 html과 Js를 다운로드 받는다.
4. 다운이 완료된 Js가 실행되고 데이터를 위한 API가 호출된다.
5. 서버가 API로부터 요청에 응답한다.
6. API로부터 받아온 데이터를 placeholder 자리에 넣어준다.(페이지는 상호작용이 가능해짐)  
`CDN : 지리적인 제약 없이 전 세계 사용자에게 빠르고 안전하게 컨텐츠 전송을 할 수 있는 기술`  


# <span style="color:green">SSR(Server Side Rendering)</span>
서버쪽에서 렌더링 준비를 마친 상태로 클라이언트에 전달하는 방식  
서버 측에서 페이지를 렌더링한다는 의미로, 서버에서 브라우저에 보일 HTML파일을 미리 준비해서 응답해 주는 형식이다.  

##### <span style="color:brown">SSR 동작 과정</span>
![ssr](https://github.com/user-attachments/assets/03916309-c8c9-4561-88fd-a48a690368af)  
1. User가 WebSite 요청을 보낸다.
2. 서버는 즉시 렌더링 가능한 html파일을 만든다.
3. 클라이언트에 전달되는 순간 이미 렌더링 준비가 되어있기 때문에 html은 즉시 렌더링이 된다. 하지만 사이트 자체는 조작 불가능하다.
4. 클라이언트가 Js를 다운받는다.
5. 다운 받고 있는 사이에 유저는 컨텐츠를 볼 수 있지만 사이트를 조작할 수는 없다. 하지만 사용자의 조작을 기억하고 있는다.
6. 브라우저가 Js 프레임 워크를 실행한다.
7. Js까지 성공적으로 컴파일 되었기 때문에 기억하고 있던 사용자 조작이 실행되고 이제 웹 페이지는 상호작용이 가능해진다.


# <span style="color:green">CSR과 SSR 차이</span>
1. 웹 페이지를 로딩하는 시간  
  웹 페이지 로딩의 종류는 두 가지로 나눌 수 있다.
  - 첫 페이지 로딩 시간
    - CSR의 경우 html, CSS와 모든 스크립트들을 한 번에 불러온다. 반면 SSR은 필요한 부분의 html과 스크립트들만 불러오게 된다. 따라서 평균적으로 SSR이 더 빠르다.
  - 나머지 로딩 시간
    - 첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정해보자. CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르지만, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행하기에 CSR보다 느리다.
2. SEO 대응  
  검색 엔진은 자동화된 로봇인 '크롤러'로 웹 사이트들을 읽는다. CSR은 Js를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 Js가 실행되어야 MetaData가 바뀌었지만, SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.
3. 서버 자원 사용  
  SSR이 서버 자원을 더 많이 사용하게 된다. 매번 서버에 요청을 하기 때문이다.


# <span style="color:green">CSR을 사용하는 경우</span>
- 네트워크가 빠를 때
- 서버의 성능이 좋지 않을 때
- 사용자에게 보여줘야 하는 데이터의 양이 많을 때
  - 로딩창을 띄울 수 있는 장점이 있다.
- 메인 스크립트가 가벼울 때
- SEO에 상관 없을 때
- 웹 어플리케이션에 사용자와 상호작용할 것들이 많을 때
  - 아예 렌더링 되지 않아 사용자의 행동을 막는 것이 유리함


# <span style="color:green">SSR을 사용하는 경우</span>
- 네트워크가 느릴 때
- SEO가 필요할 때
- 최초 로딩이 빨라야하는 사이트를 개발할 때
- 메인 스크립트가 크고 로딩이 매우 느릴 때
  - CSR은 메인 스크립트가 로딩이 끝나면 API로 데이터 요청을 보내지만, SSR은 한 번의 요청에 아예 렌더링 가능한 페이지가 돌아온다.
- 웹 사이트가 상호작용이 별로 없을 때

------------------------------------------------------------------------------------------------------------------------------------------------

`출처 및 참고`  
<https://velog.io/@ahsy92/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-CSR%EA%B3%BC-SSR>