[
  
  {
    "title": "Servlet",
    "url": "/posts/servlet/",
    "categories": "CS, Servlet",
    "tags": "CS, Servlet",
    "date": "2025-01-09 00:00:00 +0900",
    





    
    "snippet": "서블릿(Servlet)?서블릿은 자바 어플리케이션에서 클라이언트 요청을 처리하고 응답을 반환하는 역할을 하는 하나의 클래스자바 언어를 사용해서 클라이언트와 HTTP 요청, 응답을 주고받는 웹 환경을 구성할 수 있다.이런 역할을 수행하는 것이 서블릿이다.ex) 로그인할 때 서버가 클라이언트에서 입력되는 아이디와 비밀번호를 확인하고 결과를 응답하는데, 이...",
    "content": "서블릿(Servlet)?서블릿은 자바 어플리케이션에서 클라이언트 요청을 처리하고 응답을 반환하는 역할을 하는 하나의 클래스자바 언어를 사용해서 클라이언트와 HTTP 요청, 응답을 주고받는 웹 환경을 구성할 수 있다.이런 역할을 수행하는 것이 서블릿이다.ex) 로그인할 때 서버가 클라이언트에서 입력되는 아이디와 비밀번호를 확인하고 결과를 응답하는데, 이러한 역할을 수행하는 것이 서블릿서블릿(Servlet) 주요 특징  클라이언트의 Request에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트  HTML을 사용하여 응답  기존의 정적 웹 프로그램의 문제점을 보완하여 동적인 여러 기능을 제공  JAVA의 쓰레드를 이용하여 동작  MVC 패턴에서 Controller 역할  컨테이너에서 실행  보안 기능을 적용하기 쉬움  HTTP 프로토콜 서비스를 지원하는 javax.servlet.HttpServlet 클래스를 상속  UDP보다 처리속도가 느리다.  HTML 변경 시 서블릿을 재 컴파일해야 한다는 단점이 존재서블릿 컨테이너?서버에 서블릿을 만들었다고 해서 스스로 작동하는 것이 아니고 서블릿을 관리해주는 것이 필요한데, 이 역할을 하는 것이 서블릿 컨테이너다.예를 들어, 서블릿이 어떠한 역할을 수행하는 정의서라고 한다면, 서블릿 컨테이너는 그 정의서를 보고 수행한다고 볼 수 있다.클라이언트의 요청을 받아서 응답을 할 수 있게 웹 서버와 소켓으로 통신하며, 대표적인 예로 톰캣(Tomcat)이 있다.톰캣은 실제로 웹 서버와 통신하여 JSP와 서블릿이 작동하는 환경을 제공한다.HttpServletRequestHTTP 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더 정보, 파라미터, 쿠키, URL, URI 등의 정보를 읽어들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있다.HttpServletResponseWAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여 서블릿에게 전달하고 이 객체를 활용하여 content type, 응답 코드, 응답 메시지 등을 전송한다.서블릿 컨테이너의 기능  서블릿 생명주기 관리          서블릿 컨테이너는 서블릿의 탄생과 죽음을 관리한다. 서블릿 클래스를 로딩하여 인스턴스화하고, 초기화 메서드를 호출하고, 요청이 들어오면 적절한 서블릿 메서드를 찾아서 동작한다. 또한 서블릿의 생명이 다하면 가비지 컬렉션(Garbage Collection)을 통해 메모리에서 제거한다.        통신 지원          서블릿 컨테이너는 웹 서버와 소켓을 만들어서 클라이언트의 요청을 받고 응답할 수 있는 통신을 지원해준다. 통신을 하기 위한 listen, accept 등의 과정을 API로 제공하여 복잡한 과정을 생략해주기 때문에 개발자가 비즈니스 로직 개발에 집중할 수 있게 도와준다.        멀티쓰레드 지원 및 관리          서블릿 컨테이너는 클라이언트의 요청을 받을 때마다 새로운 자바 쓰레드를 생성한다. 따라서 동시에 여러 요청이 들어와도 멀티쓰레드 환경에서 동시다발적인 작업을 관리할 수 있다.        선언적 보안 관리          서블릿 컨테이너는 보안 관련된 기능을 지원한다. 그렇기에 서블릿 또는 자바 클래스 안에 보안 관련된 메서드를 구현하지 않아도 된다. 대체적으로 보안관리는 XML 배포 서술자에 기록하기 때문에 보안이슈로 소스를 수정할 일이 생겨도 자바 소스 코드를 수정하여 다시 컴파일하지 않아도 된다.        여러 서블릿 객체를 싱글톤으로 관리한다.서블릿 동작 과정  사용자가 URL을 입력하면 HTTP Request가 Servlet Container로 전송된다.  요청을 전송받은 서블릿 컨테이너는 HttpServletRequest, HttpServletResponse 객체 생성한다.  설정파일(web.xml)을 기반으로 사용자가 요청한 URL을 맵핑할 서블릿을 탐색한다.  해당 서블릿 인스턴스 존재의 유무를 확인한 후, 없으면 init() 메서드를 호출하여 생성한다.  해당 서블릿에서 service() 메서드를 호출한 후 클라이언트의 GET, POST 여부에 따라 doGet() 또는 doPost()를 호출한다.  doGet() 혹은 doPost() 메서드는 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보낸다.  응답을 처리하였으면 distroy() 메서드를 실행하여 HttpServletRequest, HttpServletResponse 객체 소멸시킨다.web.xml : 서블릿을 작성했다면, 해당 서블릿을 사용자가 요청한 경로와 맵핑 시켜야 한다. 그래야 WAS에서 맵핑된 정보를 읽고, 브라우저에서 해당 URL로 HTTP 요청 했을 때 해당 서블릿으로 요청을 전달해 줄 수 있다. 소스를 분석할 때에도 먼저 확인해야 할 부분이다. 톰캣을 예로 들면 웹 어플리케이션 서비스 처리에 대해 정의된 환경 설정 파일이 server 디렉터리의 web.xml에 있다.서블릿 작성 예시public class myServlet extends HttpServlet {    @Override    public void init(ServletConfig config) throws ServletException {        System.out.println(\"init method 호출!\");    }    @Override    public void destroy() {        System.out.println(\"destroy method 호출!\");    }    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response)        throws ServletException, IOException    {        System.out.println(\"doGet service method 호출!\");    }    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response)        throws ServletException, IOException    {        System.out.println(\"doPost service method 호출!\");    }}init()서블릿이 처음으로 요청될 때 초기화를 하는 메서드.클래스를 new해서 사용하듯 서블릿 클래스도 초기화를 해주어야 사용이 가능하다.이렇게 초기화된 서블릿은 싱글톤으로 관리되어 다음에 한번 더 해당 서블릿 클래스를 호출하면 초기화가 다시 일어나는 것이 아니라 기존에 있던 서블릿 클래스를 호출한다.service()서블릿 컨테이너가 요청을 받고 응답을 내려줄 때 필요한 서블릿의 service 메서드다.Servlet interface를 구현한 HttpServlet 클래스의 doGet, doPost같은 메서드들이 호출된다.destroy()더 이상 사용되지 않는 서블릿 클래스는 주기적으로 서블릿 컨테이너가 destroy() 메서드를 호출하여 제거한다.이렇게 제거된 서블릿은 service 메서드들에 해당하는 모든 쓰레드들이 종료되거나 사용시간이 오래되어 타임아웃된 경우에 이 클래스를 다시 사용하기 위해서는 init()을 다시 해줘야 한다.참고https://velog.io/@falling_star3/Tomcat-%EC%84%9C%EB%B8%94%EB%A6%BFServlet%EC%9D%B4%EB%9E%80https://mingyum119.tistory.com/313https://s-y-130.tistory.com/113"
  },
  
  {
    "title": "웹 서버와 WAS",
    "url": "/posts/webServer_was/",
    "categories": "CS, WAS",
    "tags": "CS, WAS",
    "date": "2025-01-08 00:00:00 +0900",
    





    
    "snippet": "Web Server웹 브라우저 클라이언트로부터 HTTP 요청을 받아들이고 HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램웹 서버란 클라이언트가 웹 브라우저에서 어떠한 페이지 요청을 하면 웹 서버에서 그 요청을 받아 정적 컨텐츠를 제공하는 서버다.그렇다고 정적 컨텐츠만 제공하는 것이 아니라 웹 서버가 동적 컨텐츠를 요청 받으면 WAS에게 해당...",
    "content": "Web Server웹 브라우저 클라이언트로부터 HTTP 요청을 받아들이고 HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램웹 서버란 클라이언트가 웹 브라우저에서 어떠한 페이지 요청을 하면 웹 서버에서 그 요청을 받아 정적 컨텐츠를 제공하는 서버다.그렇다고 정적 컨텐츠만 제공하는 것이 아니라 웹 서버가 동적 컨텐츠를 요청 받으면 WAS에게 해당 요청을 넘겨주고, WAS에서 처리한 결과를클라이언트에게 전달해주는 역할도 한다.대표적인 웹 서버로는 Apache, Nginx가 있다.정적 컨텐츠 : 단순 HTML문서, CSS, javascript, 이미지, 파일 등 즉시 응답 가능한 컨텐츠WAS인터넷 상에서 HTTP 프로토콜을 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어로서, 주로 동적 서버 컨텐츠를 수행하는 것으로 웹 서버와 구별이 되며, 주로 데이터베이스 서버와 같이 수행WAS는 웹 서버와 웹 컨테이너가 합쳐진 형태로써, 웹 서버 단독으로는 처리할 수 없는 데이터베이스의 조회나 다양한 로직 처리가 필요한 동적 컨텐츠를 제공한다.덕분에 사용자의 다양한 요구에 맞는 웹 서비스를 제공할 수 있다.WAS는 JSP, Servlet 구동환경을 제공해주기 때문에 웹 컨테이너 또는 서블릿 컨테이너라고도 불린다.대표적인 WAS 종류로는 Tomcat, Jetty, Undertow가 있다.웹 컨테이너 : 웹 서버가 보낸 JSP, PHP 등의 파일을 수행한 결과를 다시 웹 서버로 보내주는 역할컨테이너 : JSP, Servlet을 실행시킬 수 있는 소프트웨어Web Service Architecture웹 어플리케이션은 요청 처리 방식에 따라 다양한 구조를 가질 수 있다.  클라이언트 -&gt; Web Server -&gt; DB  클라이언트 -&gt; WAS -&gt; DB  클라이언트 -&gt; Web Server -&gt; WAS -&gt; DB주로 사용하는 아키텍처는 3번째 아키텍처이다.클라이언트 -&gt; Web Server -&gt; WAS -&gt; DB 구조의 동작 과정  Web Server는 웹 브라우저 클라이언트로부터 HTTP 요청을 받는다.  Web Server는 클라이언트 요청을 WAS에 보낸다.  WAS는 관련된 Servlet을 메모리에 올린다.  WAS는 web.xml을 참조하여 해당 Servlet에 대한 쓰레드를 생성한다. (Thread Pool 이용)  HttpServletRequest와 HttpServletResponse 객체를 생성하여 Servlet에 전달한다.          쓰레드는 Servlet의 service() 메소드를 호출한다.      service() 메소드는 요청에 맞게 doGet() 또는 doPost() 메소드를 호출한다.        protected doGet(HttpServletRequest request, HttpServletResponse response)  doGet() 또는 doPost() 메소드는 인자에 맞게 생성된 적절한 동적 페이지를 Response 객체에 담아 WAS에 전달한다.  WAS는 Response 객체를 HttpResponse 형태로 바꾸어 Web Server에 전달한다.  생성된 쓰레드를 종료하고, HttpServletRequest와 HttpServletResponse 객체를 제거한다.그렇다면 WAS가 Web Server의 기능을 모두 수행하면 되지 않을까? No  기능을 분리하여 서버 부하 방지          WAS는 DB 조회나 다양한 로직을 처리하느라 바쁘기에 단순한 정적 컨텐츠는 Web Server에서 빠르게 클라이언트에 제공하는 것이 좋다.      WAS는 기본적으로 동적 컨텐츠를 제공하기 위해 존재      정적 컨텐츠 request까지 처리한다면 정적 데이터 처리로 인해 부하가 커지게 되고, 동적 컨텐츠의 처리가 지연됨에 따라 수행 속도 저하      즉, 페이지 노출 시간 지연        물리적으로 분리하여 보안 강화          SSL에 대한 암복호화 처리에 Web Server를 사용        여러 대의 WAS를 연결 가능          Load Balancing을 위해서 Web Server를 사용      특히 대용량 웹 어플리케이션의 경우 Web Server와 WAS를 분리하고, 여러개의 서버를 사용함으로써 무중단 운영을 위한 장애 극복에 쉽게 대응 가능        여러 웹 어플리케이션 서비스 가능즉, 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 Web Server와 WAS를 분리나만의 요약Web Server는 정적 리소스를 제공, WAS는 애플리케이션 로직까지 실행 가능.하지만 Web Server도 프로그램 실행하는 기능이 있고, WAS도 Web Server의 기능을 제공하기는 한다.차이점이라고 한다면 서블릿 컨테이너의 유무와 WAS는 애플리케이션 로직을 실행하는데 더 특화되어 있다고 우선 정리해본다.참조https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.htmlhttps://velog.io/@leesomyoung/%EC%9B%B9-%EC%84%9C%EB%B2%84-vs-WAS"
  },
  
  {
    "title": "타임리프",
    "url": "/posts/thymeleaf/",
    "categories": "스프링, 타임리프",
    "tags": "스프링, 타임리프",
    "date": "2024-12-09 00:00:00 +0900",
    





    
    "snippet": "타임리프 특징  서버 사이드 HTML 렌더링(SSR)  네츄럴 템플릿  스프링 통합 지원“서버 사이드 HTML 렌더링(SSR)”타임리프는 백엔드 서버에서 HTML을 동적으로 렌더링 하는 용도로 사용된다.“네츄럴 템플릿”타임리프는 순수 HTML을 최대한 유지하는 특징이 있다.타임리프로 작성한 파일은 HTML을 유지하기 때문에 웹 브라우저에서 파일을 직접...",
    "content": "타임리프 특징  서버 사이드 HTML 렌더링(SSR)  네츄럴 템플릿  스프링 통합 지원“서버 사이드 HTML 렌더링(SSR)”타임리프는 백엔드 서버에서 HTML을 동적으로 렌더링 하는 용도로 사용된다.“네츄럴 템플릿”타임리프는 순수 HTML을 최대한 유지하는 특징이 있다.타임리프로 작성한 파일은 HTML을 유지하기 때문에 웹 브라우저에서 파일을 직접 열어도 내용을 확인할 수 있고, 서버를 통해 뷰 템플릿을 거치면 동적으로 변경된 결과를 확인할 수 있다.JSP를 포함한 다른 뷰 템플릿들은 해당 파일을 열면 소스코드와 HTML이 섞여서 웹 브라우저에서 정상적인 HTML 결과를 확인할 수 없다. 오직 서버를 통해서 렌더링 되고 HTML 응답 결과를 받아야 화면을 확인할 수 있다.반면에 타임리프로 작성된 파일은 해당 파일을 그대로 웹 브라우저에서 열어도 정상적인 HTML 결과를 확인할 수 있다.이렇게 순수 HTML을 유지하면서 뷰 템플릿도 사용할 수 있는 타임리프의 특징을 ‘네츄럴 템플릿’이라고 한다.“스프링 통합 지원”타임리프는 스프링과 자연스럽게 통합되고, 스프링의 다양한 기능을 편리하게 사용할 수 있게 지원한다.타임리프를 사용하려면 다음 선언을 하면 된다.&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;텍스트 - text, utext타임리프의 텍스트를 출력하는 기능타임리프는 기본적으로 HTML 태그의 속성에 기능을 정의해서 동작한다.HTML의 콘텐츠에 데이터를 출력할 때 ‘th:text:’를 사용하면 된다.&lt;span th:text=\"${data}\"&gt;HTML 태그의 속성이 아니라 HTML 콘텐츠 영역안에서 직접 데이터를 출력하고 싶으면 ‘[[…]]’를 사용하면 된다.컨텐츠 안에서 직접 출력하기 = [[${data}]]HTML 엔티티웹 브라우저는 ‘&lt;’를 HTML 태그의 시작으로 인식한다.따라서 ‘&lt;’를 태그의 시작이 아니라 문자로 표현할 수 있는 방법이 필요한데, 이를 HTML 엔티티라고 한다.그리고 HTML에서 사용하는 특수 문자를 HTML 엔티티로 변경하는 것을 이스케이프라고 한다.타임리프가 제공하는 ‘th:text’, ‘[[…]]’는 기본적으로 이스케이프를 제공한다.이스케이프 기능을 사용하지 않기 위해서 타임리프는 다음 두 기능을 제공한다.th:text -&gt; th:utext[[...]] -&gt; [(...)]변수 - SpringEL타임리프에서 변수를 사용할 때는 변수 표현식을 사용한다.변수 표현식 : ${...}그리고 이 변수 표현식에는 SpringEL이라는 스프링이 제공하는 표현식을 사용할 수 있다.SpringEL 다양한 표현식 사용Object  user.username : user의 username을 프로퍼티 접근 -&gt; user.getUsername()  user[‘username’] : 위와 같음 -&gt; user.getUsername()  user.getUsername() : user의 getUsername()을 직접 호출List  users[0].username : List에서 첫 번째 회원을 찾고 username 프로퍼티 접근 -&gt; list.get(0).getUsername()  users[0][‘username’] : 위와 같음  users[0].getUsername() : List에서 첫 번째 회원을 찾고 메소드 직접 호출Map  userMap[‘userA’].username : Map에서 userA를 찾고, username 프로퍼티 접근 -&gt; map.get(“userA”).getUsername()  userMap[‘userA’][‘username’] : 위와 같음  userMap[‘userA].getUsername() : Map에서 userA를 찾고 메소드 직접 호출&lt;h1&gt;SpringEL 표현식&lt;/h1&gt;&lt;ul&gt;Object    &lt;li&gt;${user.username} = &lt;span th:text=\"${user.username}\"&gt;&lt;/span&gt;&lt;/li&gt;    &lt;li&gt;${user['username']} = &lt;span th:text=\"${user['username']}\"&gt;&lt;/span&gt;&lt;/li&gt;    &lt;li&gt;${user.getUsername()} = &lt;span th:text=\"${user.getUsername()}\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;List    &lt;li&gt;${users[0].username} = &lt;span th:text=\"${users[0].username}\"&gt;&lt;/span&gt;&lt;/li&gt;    &lt;li&gt;${users[0]['username']} = &lt;span th:text=\"${users[0]['username']}\"&gt;&lt;/span&gt;    &lt;/li&gt;    &lt;li&gt;${users[0].getUsername()} = &lt;span th:text=\"${users[0].getUsername()}\"&gt;&lt;/span&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;Map    &lt;li&gt;${userMap['userA'].username} = &lt;span th:text=\"${userMap['userA'].username}\"&gt;&lt;/span&gt;&lt;/li&gt;    &lt;li&gt;${userMap['userA']['username']} = &lt;span th:text=\"${userMap['userA'] ['username']}\"&gt;&lt;/span&gt;&lt;/li&gt;    &lt;li&gt;${userMap['userA'].getUsername()} = &lt;span th:text=\"${userMap['userA'].getUsername()}\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;지역 변수 선언th:with을 사용하면 지역 변수를 선언해서 사용할 수 있다.지역 변수는 선언한 태그 안에서만 사용할 수 있다.&lt;h1&gt;지역 변수 - (th:with)&lt;/h1&gt; &lt;div th:with=\"first=${users[0]}\"&gt;    &lt;p&gt;처음 사람의 이름은 &lt;span th:text=\"${first.username}\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;기본 객체타임리프는 기본 객체를 제공한다  ${#request}  ${#response}  ${#session}  ${#servletContext}  ${#locale}#request는 HttpServletRequest객체가 그대로 제공되기 때문에 데이터를 조회하려면 request.getParameter(“data”)처럼 불편하게 접근해야한다.이를 해결하기 위해 편의 객체도 제공한다.  HTTP 요청 파라미터 접근 : param          ${param.paramData}        HTTP 세션 접근 : session          ${session.sessionData}        스프링 빈 접근 : @          ${@helloBean.hello(‘Spring!’)}      유틸리티 객체와 날짜타임리프는 문자, 숫자, 날짜, URI등을 편리하게 다루는 유틸리티 객체를 제공한다  #message : 메세지, 국제화 처리  #uris : URI 이스케이프 지원  #dates : java.util.Date 서식 지원  #calendars : java.util.Calendar 서식 지원  #temporals : 자바 8 날짜 서식 지원  #numbers : 숫자 서식 지원  #strings : 문자 관련 편의 기능  #objects : 객체 관련 기능 제공  #bools : boolean 관련 기능 제공  #arrays : 배열 관련 기능 제공  #lists, #sets, #maps : 컬렉션 관련 기능 제공  #ids : 아이디 처리 관련 기능 제공URL 링크타임리프에서 URL을 생성할 때는 @{…} 문법을 사용하면 된다.단순한 URL@{/hello} -&gt; /hello쿼리 파라미터@{/hello(param1=${param1}, param2=${param2})}  -&gt; /hello?param1=data1&amp;param2=data2  ()에 있는 부분은 쿼리 파라미터로 처리된다.경로 변수@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}  -&gt; /hello/data1/data2  URL 경로상에 변수가 있으면 ()부분은 경로 변수로 처리된다.경로 변수 + 쿼리 파라미터@{/hello/{param1}(param1=${param1}, param2=${param2})}  -&gt; /hello/data1?param2=data2  경로 변수와 쿼리 파라미터를 함께 사용할 수 있다.상대경로, 절대경로, 프로토콜 기준을 표현할 수도 있다.  /hello : 절대경로  hello : 상대경로리터럴리터럴은 소스 코드상에 고정된 값을 말하는 용어다.String a = \"Hello\";int a = 10 * 20;다음 코드에서 “Hello”는 문자 리터럴, 10, 20은 숫자 리터럴이다.타임리프에는 다음과 같은 리터럴이 있다.  문자 : ‘hello’  숫자 : 10  불린 : true, false  null : null타임리프에서 문자 리터럴은 항상 ‘‘로 감싸야 한다.&lt;span th:text=\"'hello'\"&gt;하지만 공백 없이 쭉 이어진다면 하나의 의미있는 토큰으로 인지해서 작은 따옴표를 생략할 수 있다.&lt;span th:text=\"hello\"&gt;오류&lt;span th:text=\"hello world!\"&gt;&lt;/span&gt;수정&lt;span th:text=\"'hello world!'\"&gt;&lt;/span&gt;리터럴 대체&lt;span th:text=\"|hello ${data}|\"&gt;마지막 리터럴 대체 문법을 사용하면 마치 템플릿을 사용하는 것 처럼 편리하다.연산타임리프 연산은 자바와 크게 다르지 않으며, HTML 안에서 사용하기 때문에 HTML 엔티티를 주의해야 한다.  산술연산&lt;li&gt;10 + 2 = &lt;span th:text=\"10 + 2\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;10 % 2 == 0 = &lt;span th:text=\"10 % 2 == 0\"&gt;&lt;/span&gt;&lt;/li&gt;  비교연산 : HTML 엔티티를 사용해야 하는 부분을 주의          ’&gt;(gt), &lt;(lt), &gt;=(ge), &lt;=(le), !(not), ==(eq), !=(neq, ne)’      &lt;li&gt;1 &gt; 10 = &lt;span th:text=\"1 &amp;gt; 10\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;1 gt 10 = &lt;span th:text=\"1 gt 10\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;1 &gt;= 10 = &lt;span th:text=\"1 &gt;= 10\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;1 ge 10 = &lt;span th:text=\"1 ge 10\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;1 == 10 = &lt;span th:text=\"1 == 10\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;1 != 10 = &lt;span th:text=\"1 != 10\"&gt;&lt;/span&gt;&lt;/li&gt;  조건식 : 자바의 조건식과 유사&lt;li&gt;(10 % 2 == 0)? '짝수':'홀수' = &lt;span th:text=\"(10 % 2 == 0)? '짝수':'홀수'\"&gt;&lt;/span&gt;&lt;/li&gt;  Elvis 연산자 : 조건식의 편의 버전&lt;li&gt;${data}?: '데이터가 없습니다.' = &lt;span th:text=\"${data}?: '데이터가 없습니다.'\"&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;${nullData}?: '데이터가 없습니다.' = &lt;span th:text=\"${nullData}?: '데이터가 없습니다.'\"&gt;&lt;/span&gt;&lt;/li&gt;  No_Operation : _인 경우 마치 타임리프가 실행되지 않는 것 처럼 동작한다.&lt;li&gt;${data}?: _ = &lt;span th:text=\"${data}?: _\"&gt;데이터가 없습니다.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;${nullData}?: _ = &lt;span th:text=\"${nullData}?: _\"&gt;데이터가 없습니다.&lt;/span&gt;&lt;/li&gt;속성 값 설정타임리프 태그 속성타임리프는 주로 HTML 태그에 th:* 속성을 지정하는 방식으로 동작한다.th:*로 속성을 적용하면 기존 속성을 대체한다.기존 속성이 없으면 새로 만든다.속성 설정th:* 속성을 지정하면 타임리프는 기존 속성을 th:*로 지정한 속성으로 대체한다.기존 속성이 없다면 새로 만든다.&lt;input type=\"text\" name=\"mock\" th:name=\"userA\"/&gt;타임리프 렌더링 후 -&gt; &lt;input type = \"text\" name = \"userA\"/&gt;속성 추가th:attrappend : 속성 값의 뒤에 값을 추가한다.th:attrprepend : 속성 값의 앞에 값을 추가한다.th:classappend : class 속성에 자연스럽게 추가한다.- th:attrappend = &lt;input type=\"text\" class=\"text\" th:attrappend=\"class='large'\"/&gt;&lt;br/&gt;- th:attrprepend = &lt;input type=\"text\" class=\"text\" th:attrprepend=\"class='large'\"/&gt;&lt;br/&gt;- th:classappend = &lt;input type=\"text\" class=\"text\" th:classappend=\"large\"/&gt;&lt;br/&gt;checked 처리HTML에서는 input type=”checkbox” name=”active” checked=”false” -&gt; 경우에도 checked 속성이 있기에 checked 처리가 되어버린다.타임리프의 th:checked는 값이 false인 경우 checked 속성 자체를 제거한다.- checked o &lt;input type=\"checkbox\" name=\"active\" th:checked=\"true\"/&gt;&lt;br/&gt;- checked x &lt;input type=\"checkbox\" name=\"active\" th:checked=\"false\"/&gt;&lt;br/&gt;- checked=false &lt;input type=\"checkbox\" name=\"active\" checked=\"false\"/&gt;&lt;br/&gt;반복타임리프에서 반복은 th:each를 사용한다반복 기능tr th:each=”user : ${users}”  반복할 때 오른쪽 컬렉션 (${users})의 값을 하나씩 꺼내서 왼쪽 변수(user)에 담아서 태그를 반복 실행한다.  th:each는 List뿐만 아니라 배열, java.util.Iterable, java.util.Enumeration을 구현한 모든 객체를 반복에 사용할 수 있다.  Map도 사용할 수 있는데 이 경우 변수에 담기는 값은 Map.Entry이다.반복 상태 유지tr th:each=”user, userStat : ${users}”반복의 두번째 파라미터를 설정해서 반복의 상태를 확인할 수 있다.두번째 파라미터는 생략 가능한데, 생략하면 지정한 변수명(user) + Stat가 된다.위에서는 user + Stat = userStat이므로 생략 가능하다.반복 상태 유지 기능  index : 0부터 시작하는 값  count : 1부터 시작하는 값  size : 전체 사이즈  even, odd : 홀수, 짝수 여부(boolean)  first, last : 처음, 마지막 여부(boolean)  current : 현재 객체조건부 평가타임리프의 조건식if, unless(if의 반대)타임리프는 해당 조건이 맞지 않으면 태그 자체를 렌더링하지 않는다.만약 다음 조건이 false인 경우 &lt;span&gt;...&lt;span&gt;부분 자체가 렌더링되지 않고 사라진다.&lt;span th:text=\"'미성년자'\" th:if=\"${user.age lt 20}\"&gt;&lt;/span&gt;switch*은 만족하는 조건이 없을 때 사용하는 디폴트다.주석표준 HTML 주석자바스크립트의 표준 HTML 주석은 타임리프가 렌더링하지 않고, 그대로 남겨둔다.타임리프 파서 주석타임리프 파서 주석은 타임리프의 진짜 주석. 렌더링에서 주석부분을 제거하며, 타임리프에서는 대부분 이것을 사용한다.타임리프 프로토타입 주석타임리프 프로토타입은 HTML 주석에 약간의 구문을 추가했다.  HTML 파일을 웹 브라우저에서 그대로 열어보면 HTML 주석이기 때문에 이 부분을 웹 브라우저가 렌더링하지 않는다.  타임리프 렌더링을 거치면 이 부분이 정상 렌더링 된다.  즉, HTML 파일을 그대로 열어보면 주석처리가 되지만, 타임리프를 렌더링 한 경우에만 보이는 기능이다.블록&lt;th:block&gt;은 HTML 태그가 아닌 타임리프의 유일한 자체 태그이다.타임리프의 특성상 HTML 태그안에 속성으로 기능을 정의해서 사용하는데, 다음과 같은 예시처럼 사용하기 애매한 경우에 &lt;th:block&gt;을 사용한다.렌더링할 때 제거된다.&lt;th:block th:each=\"user : ${users}\"&gt;  &lt;div&gt;  사용자 이름1 &lt;span th:text=\"${user.username}\"&gt;&lt;/span&gt;  사용자 나이1 &lt;span th:text=\"${user.age}\"&gt;&lt;/span&gt;   &lt;/div&gt;   &lt;div&gt;  요약 &lt;span th:text=\"${user.username} + ' / ' + ${user.age}\"&gt;&lt;/span&gt;   &lt;/div&gt;&lt;/th:block&gt;자바스크립트 인라인타임리프는 자바스크립트에서 타임리프를 편리하게 사용할 수 있는 자바스크립트 인라인 기능을 제공한다.다음과 같이 적용하면 된다.&lt;script th:inline=\"javascript\"&gt;텍스트 렌더링var username = [[${user.username}]];인라인 사용 전 -&gt; var username = userA;인라인 사용 후 -&gt; var username = \"userA\";인라인 사용 전 렌더링 결과를 보면 userA라는 변수 이름이 남아있다.타임리프 입장에서는 정확하게 렌더링 한 것이지만 개발자 입장에서는 “userA”라는 문자를 기대했을 것이다.결과적으로는 userA가 변수명으로 사용되어서 자바스크립트 오류가 발생한다.숫자의 경우에는 \"가 필요 없기 때문에 정상 렌더링 된다.인라인 사용 후 렌더링 결과를 보면 문자 타입인 경우 \"를 포함시켜준다.자바스크립트에서 문제가 될 수 있는 문자가 포함되어 있으면 이스케이프 처리도 해준다.\" -&gt; \\\"자바스크립트 내츄럴 템플릿타임리프는 HTML 파일을 직접 열어도 동작하는 내츄럴 템플릿 기능을 제공한다.자바스크립트 인라인 기능을 사용하면 주석을 활용해서 이 기능을 사용할 수 있다.var username2 = /*[[${user.username}]]*/ \"test username\";인라인 사용 전 -&gt; var username2 = /*userA*/ \"test username\";인라인 사용 후 -&gt; var username2 = \"userA\";인라인 사용 전 결과를 보면 순수하게 해석을 하기에 내츄럴 템플릿 기능이 동작하지 않고 렌더링 내용이 주석처리 된다.인라인 사용 후 결과를 보면 주석 부분이 제거되고, “userA”가 정확하게 적용된다.객체타임리프의 자바스크립트 인라인 기능을 사용하면 객체를 JSON으로 자동 변환해준다.var user = [[${user}]];인라인 사용 전 -&gt; var user = BasicController.User(username=userA, age=10);인라인 사용 후 -&gt; var user = {\"username\":\"userA\",\"age\":10};인라인 사용 전은 객체의 toString()이 호출된 값이다.인라인 사용 후는 객체를 JSON으로 변환해준다.자바스크립트 인라인 each자바스크립트 인라인은 each를 지원하며, 다음과 같이 사용한다.&lt;!-- 자바스크립트 인라인 each --&gt; &lt;script th:inline=\"javascript\"&gt;    [# th:each=\"user, stat : ${users}\"]    var user[[${stat.count}]] = [[${user}]];    [/] &lt;/script&gt;템플릿 조각웹 페이지를 개발할 때 공통 영역이 많이 존재한다.이런 부분을 코드를 복사해서 사용한다면 여러 페이지를 다 수정해야 하므로 상당히 비효율적이다.타임리프는 이런 문제를 해결하기 위해 템플릿 조각과 레이아웃 기능을 지원한다.템플릿 레이아웃템플릿 조각은 일부 코드 조각을 가지고 와서 사용했다면, 템플릿 레이아웃은 코드 조각을 레이아웃에 넘겨서 사용하는 방법이다.예를 들어서 &lt;head&gt;에 공통적으로 사용하는 css, javascript같은 정보들이 있는데 이러한 공통 정보들을 한 곳에 모아두고, 공통으로 사용하지만 각 페이지마다 필요한 정보를 더 추가해서 사용하고 싶은 경우 사용한다."
  },
  
  {
    "title": "프로그래머스 Lv0 부분 문자열",
    "url": "/posts/part-string/",
    "categories": "코딩테스트, 프로그래머스",
    "tags": "코딩테스트, 프로그래머스, Lv0",
    "date": "2024-12-04 00:00:00 +0900",
    





    
    "snippet": "처음에는 for문을 돌려서 풀어볼까 하다가 조금 더 간단하게 풀이하는 방법이 있을 것 같아서 검색해봤다.contains() : 대상 문자열의 특정 문자열이 포함되었는지 여부를 알고자 할 때 사용 (boolean타입 반환)indexOf() : 대상 문자열의 특정 문자의 index값을 찾고자 할 때 사용 (해당 index값 반환)matches() : 대상...",
    "content": "처음에는 for문을 돌려서 풀어볼까 하다가 조금 더 간단하게 풀이하는 방법이 있을 것 같아서 검색해봤다.contains() : 대상 문자열의 특정 문자열이 포함되었는지 여부를 알고자 할 때 사용 (boolean타입 반환)indexOf() : 대상 문자열의 특정 문자의 index값을 찾고자 할 때 사용 (해당 index값 반환)matches() : 대상 문자열의 정규표현식이 포함되었는지 여부를 알고싶을 때 사용 (boolean타입 반환)class Solution {    public int solution(String str1, String str2) {        int answer = 0;                if (str2.contains(str1)){            answer = 1;        }                return answer;    }}"
  },
  
  {
    "title": "프로그래머스 Lv0 뒤에서 5등까지",
    "url": "/posts/back5/",
    "categories": "코딩테스트, 프로그래머스",
    "tags": "코딩테스트, 프로그래머스, Lv0",
    "date": "2024-12-04 00:00:00 +0900",
    





    
    "snippet": "idx 변수를 세워 하나씩 값을 비교해나가며 크고 작음을 비교해볼까 하다가 문득 Arrays.sort메소드가 생각나서 정리한다.오름차순 정렬Arrays.sort()내림차순 정렬Integer arr[] = {1, 2, 3, 4, 5};Arrays.sort(arr, Collections.reverseOrder());배열을 내림차순으로 정렬하고자 할 때, ...",
    "content": "idx 변수를 세워 하나씩 값을 비교해나가며 크고 작음을 비교해볼까 하다가 문득 Arrays.sort메소드가 생각나서 정리한다.오름차순 정렬Arrays.sort()내림차순 정렬Integer arr[] = {1, 2, 3, 4, 5};Arrays.sort(arr, Collections.reverseOrder());배열을 내림차순으로 정렬하고자 할 때, 기본 타입 배열이라면 래퍼클래스로 만들어 두번째 인자에 넣어주어야 한다.(String은 기본 타입이 아니기에 그냥 사용해주면 될 것 같다)추가적으로 내림차순 정렬할 때 Collections를 사용할 때와 Comparator를 사용할 때의 차이점을 알아놔야할 것 같다.우선 Collections.reverseOrder()는 주로 List에 사용하며 Collections.sort와 함께 사용한다.Arrays.sort와 함께 사용하지 못하는 것은 아니지만 Object 배열처럼 서로 다른 타입이 섞인 배열에서는 런타입 에러가 발생할 가능성이 있다.웬만하면 Collections.sort를 사용하고자 한다.List&lt;Integer&gt; list = Arrays.asList(1, 3, 2, 5, 4);Collections.sort(list, Collections.reverseOrder());System.out.println(list); // [5, 4, 3, 2, 1]Comparator.reverseOrder()는 배열과 List 모두 사용 가능하며, Arrays.sort와 함께 사용한다.Integer[] arr = {1, 3, 2, 5, 4};Arrays.sort(arr, Comparator.reverseOrder());System.out.println(Arrays.toString(arr)); // [5, 4, 3, 2, 1]import java.util.*;class Solution {    public int[] solution(int[] num_list) {        int[] answer = new int[5];                Arrays.sort(num_list);                for (int i = 0; i &lt; 5; i++){            answer[i] = num_list[i];        }                return answer;    }}"
  },
  
  {
    "title": "프로그래머스 Lv0 배열 만들기 2",
    "url": "/posts/arr/",
    "categories": "코딩테스트, 프로그래머스",
    "tags": "코딩테스트, 프로그래머스, Lv0",
    "date": "2024-12-02 00:00:00 +0900",
    





    
    "snippet": "int값을 문자열로 바꾸는 생각까지는 했는데, “0”과 “5”로 이루어졌는지 검증하는 단계에서 문자열을 toCharArray()를 통해 다시 반복문 돌릴 생각은 하지 못했다.다음에 다시 풀 때 이 부분만 주의하고 다시 풀어보면 쉬울 듯 하다.int값을 String으로 변환하는 방법  String.valueOf()  Integer.toString()St...",
    "content": "int값을 문자열로 바꾸는 생각까지는 했는데, “0”과 “5”로 이루어졌는지 검증하는 단계에서 문자열을 toCharArray()를 통해 다시 반복문 돌릴 생각은 하지 못했다.다음에 다시 풀 때 이 부분만 주의하고 다시 풀어보면 쉬울 듯 하다.int값을 String으로 변환하는 방법  String.valueOf()  Integer.toString()String을 int로 변환하는 방법  Integer.parseInt()  Integer.valueOf()int값을 단일 문자(char)로 변환하는 방법int 값이 한 자리 숫자인 경우 문자 ‘0’을 더하면 해당 숫자를 문자로 변환할 수 있다.int num = 5;char ch = (char) (number + '0');char를 int로 변환하는 방법char에서 ‘0’을 빼면 해당 숫자의 정수값을 얻을 수 있다.char ch = '5';int number = ch - '0';import java.util.*;class Solution {    public ArrayList&lt;Integer&gt; solution(int l, int r) {        ArrayList&lt;Integer&gt; answer = new ArrayList&lt;&gt;();                for (int i = l; i &lt;= r; i++){            String number = String.valueOf(i);            boolean isValid = true;                        for (char digit : number.toCharArray()){                if (digit != '0' &amp;&amp; digit != '5'){                    isValid = false;                    break;                }            }                        if(isValid){                answer.add(i);            }                    }                if(answer.isEmpty()){            answer.add(-1);        }                return answer;    }}"
  },
  
  {
    "title": "프로그래머스 Lv0 대소문자 바꿔서 출력하기",
    "url": "/posts/Upper-Lower/",
    "categories": "코딩테스트, 프로그래머스",
    "tags": "코딩테스트, 프로그래머스, Lv0",
    "date": "2024-11-29 00:00:00 +0900",
    





    
    "snippet": "소문자 –&gt; 대문자 : toUpperCase()대문자 –&gt; 소문자 : toLowerCase()toCharArray()란?String 문자열을 char형 배열로 바꿔서 반환해주는 메소드“test”라는 문자열이 있으면arr[0] = ‘t’arr[1] = ‘e’arr[2] = ‘s’arr[3] = ‘t’charAt 함수String 타입의 데이터(...",
    "content": "소문자 –&gt; 대문자 : toUpperCase()대문자 –&gt; 소문자 : toLowerCase()toCharArray()란?String 문자열을 char형 배열로 바꿔서 반환해주는 메소드“test”라는 문자열이 있으면arr[0] = ‘t’arr[1] = ‘e’arr[2] = ‘s’arr[3] = ‘t’charAt 함수String 타입의 데이터(문자열)에서 특정 문자를 char 타입으로 변환할 때 사용하는 함수import java.util.Scanner;public class Solution {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        String a = sc.next();                String answer = \"\";                char[] arr = a.toCharArray();                for(int i = 0; i &lt; arr.length; i++){            if(Character.isUpperCase(arr[i])){                answer += Character.toLowerCase(arr[i]);            } else{                answer += Character.toUpperCase(arr[i]);            }        }        System.out.println(answer);    }}아스키코드로도 풀이가 가능할 듯 하다."
  }
  
]

