

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>꼽사리구나의 블로그</title>
  <subtitle>공부한 것을 정리하는 나만의 블로그</subtitle>
  <updated>2025-01-08T21:14:21+09:00</updated>
  <author>
    <name>김현우</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="ko-KR"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator>
  <rights> © 2025 김현우 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>타임리프</title>
    <link href="http://localhost:4000/posts/thymeleaf/" rel="alternate" type="text/html" title="타임리프" />
    <published>2024-12-09T00:00:00+09:00</published>
  
    <updated>2025-01-08T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/thymeleaf/</id>
    <content type="text/html" src="http://localhost:4000/posts/thymeleaf/" />
    <author>
      <name>김현우</name>
    </author>

  
    
    <category term="스프링" />
    
    <category term="타임리프" />
    
  

  <summary>타임리프 특징

  서버 사이드 HTML 렌더링(SSR)
  네츄럴 템플릿
  스프링 통합 지원


“서버 사이드 HTML 렌더링(SSR)”
타임리프는 백엔드 서버에서 HTML을 동적으로 렌더링 하는 용도로 사용된다.

“네츄럴 템플릿”
타임리프는 순수 HTML을 최대한 유지하는 특징이 있다.
타임리프로 작성한 파일은 HTML을 유지하기 때문에 웹 브라우저에서 파일을 직접 열어도 내용을 확인할 수 있고, 서버를 통해 뷰 템플릿을 거치면 동적으로 변경된 결과를 확인할 수 있다.
JSP를 포함한 다른 뷰 템플릿들은 해당 파일을 열면 소스코드와 HTML이 섞여서 웹 브라우저에서 정상적인 HTML 결과를 확인할 수 없다. 오직 서버를 통해서 렌더링 되고 HTML 응답 결과를 받아야 화면을 확인할 수 있다.
반...</summary>

  </entry>

  
  <entry>
    <title>프로그래머스 Lv0 부분 문자열</title>
    <link href="http://localhost:4000/posts/part-string/" rel="alternate" type="text/html" title="프로그래머스 Lv0 부분 문자열" />
    <published>2024-12-04T00:00:00+09:00</published>
  
    <updated>2024-12-04T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/part-string/</id>
    <content type="text/html" src="http://localhost:4000/posts/part-string/" />
    <author>
      <name>김현우</name>
    </author>

  
    
    <category term="코딩테스트" />
    
    <category term="프로그래머스" />
    
  

  <summary>처음에는 for문을 돌려서 풀어볼까 하다가 조금 더 간단하게 풀이하는 방법이 있을 것 같아서 검색해봤다.

contains() : 대상 문자열의 특정 문자열이 포함되었는지 여부를 알고자 할 때 사용 (boolean타입 반환)
indexOf() : 대상 문자열의 특정 문자의 index값을 찾고자 할 때 사용 (해당 index값 반환)
matches() : 대상 문자열의 정규표현식이 포함되었는지 여부를 알고싶을 때 사용 (boolean타입 반환)

class Solution {
    public int solution(String str1, String str2) {
        int answer = 0;
        
        if (str2.contains(str1)){
          ...</summary>

  </entry>

  
  <entry>
    <title>프로그래머스 Lv0 뒤에서 5등까지</title>
    <link href="http://localhost:4000/posts/back5/" rel="alternate" type="text/html" title="프로그래머스 Lv0 뒤에서 5등까지" />
    <published>2024-12-04T00:00:00+09:00</published>
  
    <updated>2024-12-04T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/back5/</id>
    <content type="text/html" src="http://localhost:4000/posts/back5/" />
    <author>
      <name>김현우</name>
    </author>

  
    
    <category term="코딩테스트" />
    
    <category term="프로그래머스" />
    
  

  <summary>idx 변수를 세워 하나씩 값을 비교해나가며 크고 작음을 비교해볼까 하다가 문득 Arrays.sort메소드가 생각나서 정리한다.

오름차순 정렬
Arrays.sort()


내림차순 정렬
Integer arr[] = {1, 2, 3, 4, 5};
Arrays.sort(arr, Collections.reverseOrder());

배열을 내림차순으로 정렬하고자 할 때, 기본 타입 배열이라면 래퍼클래스로 만들어 두번째 인자에 넣어주어야 한다.
(String은 기본 타입이 아니기에 그냥 사용해주면 될 것 같다)

추가적으로 내림차순 정렬할 때 Collections를 사용할 때와 Comparator를 사용할 때의 차이점을 알아놔야할 것 같다.
우선 Collections.reverseOrder()는 주로 Lis...</summary>

  </entry>

  
  <entry>
    <title>프로그래머스 Lv0 배열 만들기 2</title>
    <link href="http://localhost:4000/posts/arr/" rel="alternate" type="text/html" title="프로그래머스 Lv0 배열 만들기 2" />
    <published>2024-12-02T00:00:00+09:00</published>
  
    <updated>2024-12-02T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/arr/</id>
    <content type="text/html" src="http://localhost:4000/posts/arr/" />
    <author>
      <name>김현우</name>
    </author>

  
    
    <category term="코딩테스트" />
    
    <category term="프로그래머스" />
    
  

  <summary>int값을 문자열로 바꾸는 생각까지는 했는데, “0”과 “5”로 이루어졌는지 검증하는 단계에서 문자열을 toCharArray()를 통해 다시 반복문 돌릴 생각은 하지 못했다.
다음에 다시 풀 때 이 부분만 주의하고 다시 풀어보면 쉬울 듯 하다.

int값을 String으로 변환하는 방법

  String.valueOf()
  Integer.toString()


String을 int로 변환하는 방법

  Integer.parseInt()
  Integer.valueOf()


int값을 단일 문자(char)로 변환하는 방법
int 값이 한 자리 숫자인 경우 문자 ‘0’을 더하면 해당 숫자를 문자로 변환할 수 있다.
int num = 5;
char ch = (char) (number + &amp;#39;0&amp;#39;);


c...</summary>

  </entry>

  
  <entry>
    <title>프로그래머스 Lv0 대소문자 바꿔서 출력하기</title>
    <link href="http://localhost:4000/posts/Upper-Lower/" rel="alternate" type="text/html" title="프로그래머스 Lv0 대소문자 바꿔서 출력하기" />
    <published>2024-11-29T00:00:00+09:00</published>
  
    <updated>2024-11-29T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/Upper-Lower/</id>
    <content type="text/html" src="http://localhost:4000/posts/Upper-Lower/" />
    <author>
      <name>김현우</name>
    </author>

  
    
    <category term="코딩테스트" />
    
    <category term="프로그래머스" />
    
  

  <summary>소문자 –&amp;amp;gt; 대문자 : toUpperCase()
대문자 –&amp;amp;gt; 소문자 : toLowerCase()

toCharArray()란?
String 문자열을 char형 배열로 바꿔서 반환해주는 메소드
“test”라는 문자열이 있으면
arr[0] = ‘t’
arr[1] = ‘e’
arr[2] = ‘s’
arr[3] = ‘t’

charAt 함수
String 타입의 데이터(문자열)에서 특정 문자를 char 타입으로 변환할 때 사용하는 함수

import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        ...</summary>

  </entry>

</feed>


